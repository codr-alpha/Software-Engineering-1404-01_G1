---

### Amirkabir University of Technology
**(Tehran Polytechnic)**
**Department of Computer Engineering**

# Software Engineering Project 1
**Phase 3 of the Software Engineering Methods 1 Course Project**

*   All project stages must be carried out in groups, and uploading by one group member is sufficient.
*   The file must be a `.zip` named in the format: `P3_GroupID_Studentnumber1_Studentnumber2_Studentnumber3`.
*   If you encounter any issues, communicate via the Teaching Assistant email: (se.ce.aut.40201@gmail.com).
*   For faster access to announcements, join the Telegram channel.
*   Given that services selected by groups differ, the submitted responses are expected to be distinct from one another.

**Fall 2025 (1404)**

---

### Description of Stages

**Implementation**
In Phase 3 of the Software Engineering project, the focus shifts from design to the practical realization of the system. This stage is the peak of the Agile cycle. Here, the emphasis is on executing the project based on the requirements specified and diagrams created in previous phases. Implementation is a vital stage because it transforms conceptual designs into a functional software system. Completing the implementation stage is the final step in the Agile methodology. This highlights the iterative nature of software development, where each stage builds upon the results of previous stages, leading to a functional product.

**Definition of Microservices**
Microservices are a collection of small, independent, and autonomous services, each responsible for a specific and related task. This architecture allows developers to design, implement, and manage different parts of a software application separately.

**1. General Project Introduction and Basic Architecture Structure**
This project is a web-based English language learning system designed within a service-oriented architecture. In this system, a collection of independent services are placed alongside each other, each responsible for a specific task, collectively providing a comprehensive tool for managing, processing, and improving data.
Each team is responsible for designing and implementing a specific service or microservice. These microservices are developed independently but must all connect to the central system so that the final project output is available to the user in a unified manner.

The central system has been implemented by the project's base team, and student teams are solely responsible for developing their own dedicated services.

In implementing services, teams have the freedom to choose their programming language and framework. If a team's service is developed outside of Django, communication must be established between the external microservice and the central Django system. This communication can be done via various methods, including gRPC or message brokers like RabbitMQ. The choice of communication method is up to the team, but it must be compatible with the general project architecture.

**2. Role and Responsibility of the Central System (Django Core)**
The central Django system acts as the main core of the project and is responsible for common capabilities across all teams. This system performs the following tasks:
*   User authentication management including registration, login, and logout.
*   maintaining user authentication state via Session and Cookie.
*   Providing common APIs to check user status.
*   Maintaining the general project structure and main routes.
*   Providing a standard connection point for team services.

All requests reaching the central Django system must be redirected to a specific path (Sub-URL) related to the team's service. Each team can define and manage its own proprietary APIs within these paths.

**3. General Project Structure and Team Development Location**
In the main repository branch, a separate folder is designated for each team. Each team is obliged to perform all changes, codes, and files related to their project solely within their team's dedicated folder.
For example, if the team is `team1`, all changes must be done in the `team1` folder. Changing the general project structure or files of other teams is not permitted, and if structural changes are needed, coordination must be done first.

For each team, a separate Application in Django has been designated, named after that team. Also, the `urls.py` file related to that Application is available to the team to define the required routes for their service.

If a team does not intend to use Django, they can develop their microservice with any other language or framework and connect to the central system via defined communication methods (such as HTTP, gRPC, or message broker).

**4. Use of Docker in Project Architecture**
Docker is used in this project as the main platform for running services. All project components, including the central system and team services, run inside Docker containers. This approach ensures the execution environment is identical for all teams, making dependency management and simultaneous service execution easier.
Each team runs its services independently in Docker, and there is no need to run them directly on the host system. Communication between services is established via the internal Docker network.

**5. Docker Compose and How to Add a New Service**
There is a `docker-compose.yml` file in each team's folder. This file is where all team services are defined. If a new service needs to be added, the team must follow these steps:
*   Define the new service in the team's `docker-compose` file.
*   Place the service in the project's shared network.
*   Define the required environment variables for the service.
*   Connect the service to the team's Gateway via Nginx.

There is no need to change the central system's `docker-compose` or that of other teams.

**6. Role of Nginx and Logic of Use**
In this project, Nginx is used as the Gateway for each team. The Gateway is the only entry point for the team from the outside, and all requests related to that team first enter Nginx.
The logic for using Nginx is that each team has only one port on the host system, and this port is connected to Nginx. Nginx decides which internal team service to forward the request to based on the URL path.

If a team adds a new service, it suffices to:
*   Add the service to `docker-compose`.
*   Define a new path for that service in the Nginx configuration file.

This is done without opening a new port on the host system.

**7. Database and Team Usage**
In the Django-based central system, a cloud MySQL database is designated as the main project database. Connection information for this database is provided to each team via Environment Variables.

Each team:
*   Receives a dedicated username and password.
*   This information is strictly for that team and must not be shared with other teams.
*   Each team's access is limited to the tables created for that team in previous phases.
*   No team has the ability to view or access other teams' tables.

To connect to the central database:
*   Simply define the variable related to the team's database connection in the `.env` file.
*   How to add this variable is explained in the `.env.example` file.
*   No other extra configuration is needed, and team services can use this variable directly.

Team access levels to the cloud database include:
*   `SELECT` (Reading data)
*   `INSERT` (Adding data)
*   `UPDATE` (Editing data)

In the development phase:
*   Teams can use a local Django database like SQLite.
*   Models and migrations run locally.
*   Applying migrations to the main database is done solely after review and approval by the Teaching Assistant team.

In case of need for:
*   Creating a new table (`CREATE`)
*   Changing table structure (`ALTER`)
*   Deleting a table (`DROP`)

Teams must:
1.  Register the relevant SQL command in the "Database" section of the related sheet available to students.
2.  Provide a brief explanation of the purpose of the change.
3.  After review and approval by the TA team, the requested change will be applied to the cloud database.

**7-1. How Teams Use the Database in Django Code**
In project settings, an independent database connection is defined for each team based on the environment variable `<TEAMNAME_DATABASE_URL>`. For example, `team1` uses the variable `TEAM1_DATABASE_URL`.

If this environment variable is not defined in the `.env` file, the project automatically uses a local SQLite database specific to that team, created in the team's folder path. This behavior allows for local development and testing without needing the cloud database.

Database request routing is done by a Router (`TeamPerAppRouter`), which ensures all read and write operations for each application are sent to the database related to that team, preventing interference between teams.

In teams' Django code, using the ORM normally is sufficient, and there is no need to manually specify the database. In special cases, the team can explicitly use their alias (e.g., `team1`).

**8. Connecting Team Services to the Central System**
Services that need to communicate with the central system must be defined in the same Docker network where Core resides. To do this, in the team's `docker-compose`:
*   The `app404_net` network is added to the service.
*   The `CORE_BASE_URL` environment variable is set.

These items are included by default, for example in each team's `docker-compose` file, so you can learn how to use them.

This way, the team service can call the central system APIs via the internal Docker address, such as:
`core:8000/api/...`
`core:8000/team1/map`

This address is valid only inside the Docker network and is used as an environment variable in the service code.

**9. Authentication and Request Routing**
User authentication is performed entirely in the central system. After user login, authentication information is stored as a Cookie. This Cookie is passed unchanged by Nginx to the team services.

Team services can check the user's status and retrieve user information if needed by sending a request to the central system's authentication APIs using the user's Cookie. The team does not need to implement authentication logic or token validation.

`CORE_BASE_URL:8000/api/auth/me/`
`CORE_BASE_URL:8000/api/auth/verify/`

**10. Access Paths and Sub-URLs**
All requests reaching the central system must be redirected to the Sub-URL related to the team service. Each team can define various paths for their service.

For example:
*   Service **writing**:
    *   `/team1/writing/`
    *   `/team1/writing/score`
*   Service **listening**:
    *   `/team2/listening`
    *   `/team2/listening/list`

By defining various paths, all requests are directed to the team's microservice, and full service management will be at the team's disposal.

**11. Project Execution Scripts and Usage**
To simplify project execution and prevent errors caused by running services manually, a set of execution scripts has been provided. These scripts are offered in two separate folders for Windows and Linux operating systems, but their operational logic is identical.

In each of these folders, there are three scripts responsible for specific tasks.

**up-all script** (with `.sh` extension in Linux and `.ps1` in Windows) is responsible for the full launch of the project. This script runs the Central System (Core) and all team services simultaneously, configures the specific port for each team, and brings up the Gateway and services related to each team. This script is suitable when running the entire project is required.

**up-team script** is used to run a specific team. This script receives the team number as input and runs only the services related to that team. Using this script is recommended for daily development and testing for each team.

**down-all script** is designed to completely stop the project. Running this script stops all team services and the central system and frees up Docker resources.

Using these scripts is considered part of the project's execution design, and running the project without them is not recommended; because port configuration, service execution order, and coordination between teams are managed centrally within these scripts.

**Quick Project Launch**
To run the project quickly, simply execute one of the following scripts from the project root:

Full project run:
`up-all`

Run a specific team:
`up-team`

Full project stop:
`down-all`

Finally, you can visit `http://localhost:8000` in your browser to view the initial project page.

**12. Visual Standards and UI/UX Coordination**
To ensure the overall appearance of the system remains unified and consistent, it is better for teams to follow the patterns and general style of the main project as much as possible when designing the user interface for their microservice pages. This ensures that users do not feel a sense of inconsistency or sudden difference in page appearance when moving between different parts of the system.

This coordination includes the following:

**1. Font and Typography**
*   The main project font is **Vazirmatn**, and it is suggested to use this font on all pages.
*   Font sizes and line spacing should ideally be selected similar to the samples in the project style files.

**2. Page Direction and Structure**
*   All pages are designed Right-to-Left (**RTL**), and teams should also maintain this direction.
*   The general page structure (Header, Main Content, and Footer) should preferably resemble the main system so the user has a familiar experience.

**3. Color Scheme and Visual Identity**
*   It is suggested that teams use the same color spectrum and avoid completely different color schemes.

**4. Header and Footer Coordination**
*   It is better if the appearance and layout of the Header and Footer on team pages are similar to the main system pages.
*   Teams can design the main content of the page freely, but preserving the general navigation framework helps project integrity.

**5. UI Element Behavior**
*   The display style of buttons, links, and hover/active states should ideally be similar to the main project.
*   This consistency allows the user to work comfortably with different sections without needing to relearn.

**Goal of this Standard**
The main goal of these items is to create a **smooth and consistent user experience**; so that the user feels they are still within a single system when using different microservices.

**Suggested Design Resources**
To get more familiar with page visual details, teams can review style files available in the project, including:
*   `style.css`
*   `microservice.css`
*   `signup.css` and `login.css`
*   `common.css` files related to each team

These files can be good guides for synchronizing page appearances.

**13. Final Conclusion**
In this architecture, each team develops its service independently but connects to the central system via specified standards. This structure allows project development to be simultaneous, organized, and manageable, and ultimately, the output of all teams is provided to the user as a unified system.